#ifndef UBLOX_H
#define UBLOX_H
#include "Arduino.h"
#include "TimeLib.h"
#include "sys/time.h"
#include "SD_card.h"

//#define RATE_1Hz
//#define RATE_5Hz
//#define RATE_10Hz
#define RXD2 32 //geel is Tx Ublox, Beitian wit is Tx
#define TXD2 33 //groen is Rx Ublox, Beitian groen is Rx
/*
#ifdef RATE_1Hz
#define SAMPLESperS 1
#define TIME_OUT_NAV_PVT 1500 //max ms between NAV_PVT messages, if RATE=1000 ms !!
#endif
#ifdef RATE_5Hz
#define SAMPLESperS 5
#define TIME_OUT_NAV_PVT 305 //max ms between NAV_PVT messages, if RATE=200 ms !!
#endif
#ifdef RATE_10Hz
#define SAMPLESperS 10
#define TIME_OUT_NAV_PVT 200 //max ms between NAV_PVT messages, if RATE=100 ms !!
#endif
*/
const char UBLOX_UBX_OUT[] PROGMEM = {
  0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x80,0x25,0x00,0x00,0x23,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xBC,0x89};//28 bytes
const char UBLOX_UBX_NAVPVT_ON[] PROGMEM = {0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1};  //NAV-PVT on 16 bytes
const char UBLOX_UBX_BD19200[] PROGMEM = {
  0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0x4B,0x00,0x00,0x23,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x62,0x2B}; //set baudrate to 19200, only UBX out
const char UBLOX_INIT[] PROGMEM = {
  /* Disable NMEA
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  */
  0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x80,0x25,0x00,0x00,0x23,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xBC,0x89,//28 bytes
  //B5   62   06   00   14   00   01   00   00   00   D0   08   00   00   80   25   00   00   23   00   01   00   00   00   00   00   BC   89 //protocol out uart 1 = only ubx, 9600baud !!!
 
  // Disable UBX
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xC0, //NAV-STATUS off
  // Enable UBX
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x09,0x00,0x01,0x00,0x00,0x00,0x00,0x1A,0xEF, //NAV-ODO on
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x14,0xC5, //NAV-STATUS on
  0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on 16 bytes
  // Rate
  //UBLOX_RATE is set in other function !!
  //0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  //0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  //0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  //0xB5,0x62,0x06,0x08,0x06,0x00,0xD0,0x07,0x01,0x00,0x01,0x00,0xED,0xBD,//(0,5Hz)
  //set low-pass velocity filter to 1m/s (odo)
  //0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x00,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x2C,0x01,
  //B5   62   06   24   24   00   FF   FF   00   03   00   00   00   00   10   27   00   00   05   00   FA   00   FA   00   64   00   2C   01   
  //0x64,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAB,0x87,
  //64   00   00   00   10   27   00   00   00   00   00   00   00   00   AB   87
  //set baudrate to 115200
  //0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0xC2,0x01,0x00,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xBA,0x52,
  //set baudrate to 19200, only UBX out
  0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x00,0x4B,0x00,0x00,0x23,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x62,0x2B,//28 bytes
};
const char UBLOX_RATE[] PROGMEM = {
  0xB5,0x62,0x06,0x08,0x06,0x00,0xD0,0x07,0x01,0x00,0x01,0x00,0xED,0xBD,//(0,5Hz)0 tot 13 config.sample_rate=1
  0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)14 tot 27 config.sample_rate=2
  0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)28 tot 41 config.sample_rate=3
  0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)42 tot 55 config.sample_rate=4
  0xB5,0x62,0x06,0x08,0x06,0x00,0xF4,0x01,0x01,0x00,0x01,0x00,0x0B,0x77, //(2Hz)56 tot 69 config.sample_rate=5
  0xB5,0x62,0x06,0x08,0x06,0x00,0x37,0x00,0x01,0x00,0x01,0x00,0x4D,0x04, //(18Hz)70 tot 83 config.sample_rate=6
  };
const char UBX_ID[] PROGMEM ={
  0xB5,0x62,0x27,0x03,0x00,0x00,0x2A,0xA5,//ask unique ID 
};
  //0xB5,0x62,0x27,0x03,0x00,0x00,0x2A,0xA5 
  //B5 62 06 01 08 00 27 03 00 00 00 00 00 00 3A F5
  //B5 62 06 01 08 00 27 03 00 01 00 00 00 00 3A F5  
const char UBX_SEA[] PROGMEM ={
   0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x05,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,//switch to dynamic sea model
  //B5 62 06 24 24 00 FF FF 05 03 00 00 00 00 10 27 00 00 05 00 FA 00 FA  
  0x00,0x64,0x00,0x2C,0x01,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4C,0xB9,////switch to dynamic sea model
  //00 64 00 2C 01 00 00 00 00 10 27 00 00 00 00 00 00 00 00 4C B9
}; 
const char UBX_PORTABLE[] PROGMEM ={
  0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x00,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,//switch to dynamic sea model
  //B5 62 06 24 24 00 FF FF 00 03 00 00 00 00 10 27 00 00  05 00 FA 00 FA
  0x00,0x64,0x00,0x2C,0x01,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x0F,////switch to dynamic sea model
  //00 64 00 2C 01 00 00 00 00 10 27 00 00  00 00 00 00 00 00 47 0F 
}; 
const char UBX_AUTOMOTIVE[] PROGMEM ={
  0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x04,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,//switch to dynamic automotive model
//B5 62 06 24 24 00 FF FF 04 03 00 00 00 00 10 27 00 00 05 00 FA 00 FA
  0x00,0x64,0x00,0x2C,0x01,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0x97,////switch to dynamic automotive model
//00 64 00 2C 01 00 00 00 00 10 27 00 00 00 00 00 00 00 00 4B 97    
};
const unsigned char UBX_HEADER[]        = { 0xB5, 0x62 };
const unsigned char NAV_POSLLH_HEADER[] = { 0x01, 0x02 };
const unsigned char NAV_STATUS_HEADER[] = { 0x01, 0x03 };
const unsigned char NAV_PVT_HEADER[] = { 0x01, 0x07 };
const unsigned char NAV_ODO_HEADER[] = { 0x01, 0x09 };
const unsigned char NAV_ACK_HEADER[] = { 0x05, 0x01 };
const unsigned char NAV_ID_HEADER[] = { 0x27, 0x03 };
enum _ubxMsgType {
  MT_NONE,
  MT_NAV_POSLLH,
  MT_NAV_STATUS,
  MT_NAV_PVT,
  MT_NAV_ODO,
  MT_NAV_ACK,
  MT_NAV_ID
};
struct NAV_POSLLH {   //28 bytes payload, total = 32 bytes
  unsigned char cls;
  unsigned char id;
  unsigned short len;
  unsigned long iTOW;
  long lon;
  long lat;
  long height;
  long hMSL;
  unsigned long hAcc;
  unsigned long vAcc;
};

struct NAV_STATUS {   //20 bytes payload, total = 24 bytes
  unsigned char cls;
  unsigned char id;
  unsigned short len;
  unsigned long iTOW;
  unsigned char gpsFix;
  char flags;
  char fixStat;
  char flags2;
  unsigned long ttff;
  unsigned long msss;
};

struct NAV_PVT {  // 88 bytes payload, 92 bytes total, with Beitian BN220 100 bytes total ????
  unsigned char cls;
  unsigned char id;
  unsigned short len;
  unsigned long iTOW;          // GPS time of week of the navigation epoch (ms)
  
  unsigned short year;         // Year (UTC) 
  unsigned char month;         // Month, range 1..12 (UTC)
  unsigned char day;           // Day of month, range 1..31 (UTC)
  unsigned char hour;          // Hour of day, range 0..23 (UTC)
  unsigned char minute;        // Minute of hour, range 0..59 (UTC)
  unsigned char second;        // Seconds of minute, range 0..60 (UTC)
  char valid;                  // Validity Flags (see graphic below)
  unsigned long tAcc;          // Time accuracy estimate (UTC) (ns)
  long nano;                   // Fraction of second, range -1e9 .. 1e9 (UTC) (ns)
  unsigned char fixType;       // GNSSfix Type, range 0..5
  char flags;                  // Fix Status Flags
  unsigned char reserved1;     // reserved
  unsigned char numSV;         // Number of satellites used in Nav Solution
  
  long lon;                    // Longitude (deg)
  long lat;                    // Latitude (deg)
  long height;                 // Height above Ellipsoid (mm)
  long hMSL;                   // Height above mean sea level (mm)
  unsigned long hAcc;          // Horizontal Accuracy Estimate (mm)
  unsigned long vAcc;          // Vertical Accuracy Estimate (mm)
  
  long velN;                   // NED north velocity (mm/s)
  long velE;                   // NED east velocity (mm/s)
  long velD;                   // NED down velocity (mm/s)
  long gSpeed;                 // Ground Speed (2-D) (mm/s)
  long heading;                // Heading of motion 2-D (deg)
  unsigned long sAcc;          // Speed Accuracy Estimate
  unsigned long headingAcc;    // Heading Accuracy Estimate
  unsigned short pDOP;         // Position dilution of precision
  short reserved2;             // Reserved
  unsigned long reserved3;     // Reserved
  long headVeh;                 //only valid for adr4.1, beitian bn220 !
  short magDec;                 //only valid for adr4.1,beitian bn220 !
  short magAcc;                //only valid for adr4.1,beitian bn220 !
};
struct NAV_ODO {   //18 bytes payload, total = 20 bytes
  unsigned char cls;
  unsigned char id;
  byte vers;
  byte reserved;
  long iTOW;
  long distance;
  long total_distance;
  long distance_std;
};
struct NAV_ACK {
  unsigned char cls;
  unsigned char id;
  unsigned short len;
  unsigned char msg_cls;
  unsigned char msg_id;
};

struct NAV_ID {
  unsigned char cls;
  unsigned char id;
  byte Version;
  byte reserved1;
  byte reserved2;
  byte reserved3;
  byte ubx_id_1;
  byte ubx_id_2;
  byte ubx_id_3;
  byte ubx_id_4;
  byte ubx_id_5;
};
/*
 "MON-VER": {
        "swVersion": C30,
        "hwVersion": C10,
        "group": ("None", {"extension": C30}),  # repeating group
    },
*/
union UBXMessage {
  //NONE none;
  NAV_POSLLH navPosllh;
  NAV_STATUS navStatus;
  NAV_PVT navPvt;
  NAV_ODO navOdo;
  NAV_ACK navAck;
  NAV_ID ubxId;
};
extern UBXMessage ubxMessage; //declaration here, definition in Ublox.cpp
//extern GPS_data Ublox(1000);
extern bool sdOK;

extern char dataStr[255];//string for logging NMEA in txt, test for write 2000 chars !!
extern char Buffer[50];
void calcChecksum(unsigned char* CK, int msgSize);
boolean compareMsgHeader(const unsigned char* msgHeader);
void Ublox_on();
void Ublox_off();
void Ublox_serial2(int delay_ms);
void Init_ublox(void);
void Set_rate_ublox(int);
void Set_GPS_Time(void);
void AddString(void);
int processGPS();
#endif
